# Lovely Period Tracker - Copilot Instructions

## Project Overview
**Lovely** is a Flutter 3.8 period tracking application with mood/symptom logging, cycle predictions, and cycle phase visualization. Built with Riverpod state management and Supabase backend.

**Flutter Version**: `>=3.8.0 <4.0.0`
**Dart SDK**: `>=2.19.0 <3.0.0`

---

## Core Development Principles

### Design Philosophy
- Create interfaces that stand out through thoughtful hierarchy, not visual noise
- Prioritize usability: every interaction should feel natural and require minimal cognitive load
- Design for young adults (20-35) with modern, sophisticated aesthetics
- Balance beauty with performance

### Code Standards
- Write clean, readable code that flows logically from top to bottom
- No verbose comments explaining obvious code (let the code speak)
- Use meaningful names that eliminate need for explanation
- Avoid AI-generated boilerplate and unnecessary abstractions
- Keep functions focused and modules cohesive

### Testing Requirements
- Write tests immediately after completing each module
- Update all affected tests after every feature change
- No feature is complete without passing tests
- Minimum coverage: 80% for business logic

---

## Design System

### Theme Configuration (main.dart)
**App uses system theme mode with single seed color generating both variants:**

**Seed Color**: Coral Sunset `#FF6F61` (young adult demographic - modern, sophisticated)

**Implementation Pattern**:
```dart
const seedColor = Color(0xFFFF6F61);

final lightColorScheme = ColorScheme.fromSeed(
  seedColor: seedColor,
  brightness: Brightness.light,
);
final darkColorScheme = ColorScheme.fromSeed(
  seedColor: seedColor,
  brightness: Brightness.dark,
);

// Use lightColorScheme and darkColorScheme in respective ThemeData
```

**Light Theme**:
- Generated from seed with `Brightness.light`
- Primary, Secondary, Tertiary, Surface auto-generated by Material 3
- Scaffold Background: White
- Text Theme: Google Fonts "Inter"

**Dark Theme**:
- Generated from seed with `Brightness.dark`
- Primary, Secondary, Tertiary, Surface auto-generated by Material 3
- Scaffold Background: `#121212`
- Text Theme: Google Fonts "Inter" (dark variant)

**Theme Mode**: `ThemeMode.system` (respects device theme preference)

### Color Architecture
**Centralized Colors**: All cycle-specific colors defined in `lib/constants/app_colors.dart`

**Theme-Aware Methods** (adapt to light/dark mode):
```dart
// Context-aware color getters for proper theme support
AppColors.getPeriodColor(context)          // Menstrual phase (red)
AppColors.getFertileWindowColor(context)   // Follicular phase (blue)
AppColors.getOvulationColor(context)       // Ovulation phase (purple)
AppColors.getPredictedPeriodColor(context) // Luteal phase (pink)
AppColors.primary                          // Primary brand color
AppColors.darkBackground                   // Dark theme containers
AppColors.success / AppColors.error        // Status colors
```

**DO:**
```dart
// Use theme-aware colors
color: AppColors.getPeriodColor(context)
backgroundColor: AppColors.darkBackground
```

**DON'T:**
```dart
// Never hardcode colors
color: Color(0xFFFF0000)
backgroundColor: Colors.grey[900]
```

### Using Theme Data in Widgets
Always respect the current theme when accessing colors:
```dart
// Get primary color that adapts to light/dark theme
Theme.of(context).colorScheme.primary

// Get surface color (dark surface in dark mode, light surface in light mode)
Theme.of(context).colorScheme.surface

// Get text theme pre-configured for current brightness
Theme.of(context).textTheme.titleMedium

// Build colors based on theme brightness
if (Theme.of(context).brightness == Brightness.dark) {
  // Dark theme colors
} else {
  // Light theme colors
}
```

### Smart Text Colors
All text on colored backgrounds MUST use `_getTextColorForBackground(backgroundColor)`:
```dart
Color _getTextColorForBackground(Color backgroundColor) {
  final luminance = backgroundColor.computeLuminance();
  return luminance > 0.5 ? Colors.black87 : Colors.white;
}
```
This ensures automatic contrast based on background luminance for accessibility.

**NEVER hardcode white/black text** - always compute based on background.

### Dark Theme Implementation
- **Default**: Dark background (AppColors.darkBackground for containers)
- **System Aware**: Uses device theme preference via `ThemeMode.system`
- **Automatic Adaptation**: All theme-aware colors from AppColors adapt to current brightness
- **Accent Colors**: Use `Colors.white.withValues(alpha: 0.1)` or `0.2` for subtle accents
- **Text Colors**: Always use `_getTextColorForBackground()` helper

---

## UI Patterns

### Containers & Sections
Wrap major sections in `Container` with consistent styling:
```dart
Container(
  margin: EdgeInsets.all(_getResponsiveSize(context, 16)),
  padding: EdgeInsets.all(_getResponsiveSize(context, 16)),
  decoration: BoxDecoration(
    color: AppColors.darkBackground,
    borderRadius: BorderRadius.circular(12),
    boxShadow: [
      BoxShadow(
        color: Colors.black26,
        blurRadius: 8,
        offset: Offset(0, 2),
      ),
    ],
  ),
  child: // content
)
```

### FilterChips (Mood/Symptoms)
Always use `Theme.of(context).colorScheme.surfaceTint` for theme-aware chip styling:
```dart
FilterChip(
  label: Row(
    mainAxisSize: MainAxisSize.min,
    children: [
      FaIcon(
        icon,
        color: _getTextColorForBackground(
          Theme.of(context).colorScheme.surfaceTint.withValues(alpha: 0.2)
        ),
      ),
      SizedBox(width: 6),
      Text(
        label,
        style: TextStyle(
          color: _getTextColorForBackground(
            Theme.of(context).colorScheme.surfaceTint.withValues(alpha: 0.2)
          ),
        ),
      ),
    ],
  ),
  backgroundColor: Theme.of(context).colorScheme.surfaceTint.withValues(alpha: 0.1),
  selectedColor: AppColors.primary.withValues(alpha: 0.3),
  side: BorderSide(
    color: isSelected
        ? AppColors.primary
        : Theme.of(context).colorScheme.surfaceTint.withValues(alpha: 0.2),
    width: 2,
  ),
)
```

**Why surfaceTint?**
- Automatically adapts to light/dark theme
- Material 3 compliant
- Provides proper contrast in both theme modes
- Better accessibility than hardcoded alpha colors

### Icons
- Use **FontAwesome icons** (via `font_awesome_flutter` package)
- Predictions use: droplet (period), heart (logged), seedling (fertile), star (ovulation)
- Icons on dark backgrounds: `color: _getTextColorForBackground(backgroundColor)`

### Responsive Sizing
Always use helper functions for sizing:
```dart
// For padding/margins
_getResponsiveSize(context, baseValue)

// For text sizes
_getResponsiveFontSize(context, baseFontSize)
```

**Implementation** (add to StatefulWidget or extract to utility):
```dart
double _getResponsiveSize(BuildContext context, double baseSize) {
  final width = MediaQuery.of(context).size.width;
  return baseSize * (width / 375); // 375 is iPhone SE width baseline
}

double _getResponsiveFontSize(BuildContext context, double baseSize) {
  final width = MediaQuery.of(context).size.width;
  return baseSize * (width / 375);
}
```

### Standout Design Principles
- Use consistent spacing (8px grid system)
- Implement micro-interactions for feedback
- Layer shadows for depth (elevation 2, 4, 8)
- Typography hierarchy: clear distinction between headings and body
- White space is a design element, not empty space

---

## Cycle Calculations

### Prediction Logic (in home_screen.dart)
```dart
// Reference date (current or last period start)
final referenceDate = _periodProvider.referenceDate ?? DateTime.now();

// Average cycle length (default 28 days)
final _averageCycleLength = 28;

// Days since reference date
final daysSince = DateTime.now().difference(referenceDate).inDays;

// Current cycle day
final currentCycleDay = (daysSince % _averageCycleLength) + 1;

// Next period (luteal phase is constant at 14 days)
final nextPeriodDate = referenceDate.add(Duration(days: _averageCycleLength));

// Ovulation (14 days before next period - luteal phase constant)
final ovulationDate = nextPeriodDate.subtract(const Duration(days: 14));

// Fertile window (5 days before and including ovulation)
final fertileWindowStart = ovulationDate.subtract(const Duration(days: 5));
final fertileWindowEnd = ovulationDate;
```

### Week Strip Colors
Check if each date falls into prediction ranges:
- **Menstrual**: nextPeriodDate ± 5 days → use `AppColors.getPeriodColor(context)`
- **Follicular**: referenceDate to (ovulationDate - 5 days) → use `AppColors.getFertileWindowColor(context)`
- **Ovulation**: ovulationDate ± 2 days → use `AppColors.getOvulationColor(context)`
- **Luteal**: ovulationDate to nextPeriodDate → use `AppColors.getPredictedPeriodColor(context)`

Use predicted phase colors even before periods are logged.

---

## State Management

### Riverpod Patterns
- Use `supabaseServiceProvider` for Supabase queries
- Keep providers in `lib/providers/`
- Use `.watch()` in ConsumerWidget/ConsumerState for reactive updates
- Use `.read()` sparingly for one-time operations

**Provider Structure**:
```dart
final exampleProvider = StateNotifierProvider<ExampleNotifier, ExampleState>((ref) {
  return ExampleNotifier();
});

class ExampleNotifier extends StateNotifier<ExampleState> {
  ExampleNotifier() : super(ExampleState.initial());
  
  Future<void> fetchData() async {
    // Business logic here
    state = state.copyWith(data: newData);
  }
}
```

### Data Flow
1. User action (tap, scroll, text input)
2. State update via provider
3. Supabase call (async)
4. Provider notifies listeners
5. UI rebuilds with new data

---

## Code Quality Standards

### Clean Code Rules

**DO:**
```dart
class PeriodRepository {
  Future<Period> fetchPeriod(String id) async {
    final response = await _supabase.from('periods').select().eq('id', id).single();
    return Period.fromJson(response);
  }
}
```

**DON'T:**
```dart
// This function fetches a period from the Supabase database
// It takes a string ID parameter and returns a Future
// containing a Period object parsed from JSON response
class PeriodRepository {
  // Fetch period method implementation
  Future<Period> fetchPeriod(String id) async {
    // Make Supabase call to get period with ID
    final response = await _supabase.from('periods').select().eq('id', id).single();
    // Parse the response and return Period object
    return Period.fromJson(response);
  }
}
```

### Naming Conventions
- Classes: `PascalCase`
- Variables/Functions: `camelCase`
- Constants: `lowerCamelCase` (Dart style)
- Private members: `_leadingUnderscore`
- Files: `snake_case.dart`

### Widget Building
- Extract complex UI into separate `_buildXyz()` methods
- Keep build() clean (max 20-30 lines logic)
- Use descriptive method names matching functionality
- Return types should be explicit

**Example**:
```dart
@override
Widget build(BuildContext context) {
  return Scaffold(
    body: Column(
      children: [
        _buildHeader(),
        _buildCycleInfo(),
        _buildPredictions(),
      ],
    ),
  );
}

Widget _buildHeader() {
  return Container(
    padding: EdgeInsets.all(_getResponsiveSize(context, 16)),
    child: Text('Cycle Overview'),
  );
}
```

### Deprecated APIs (Flutter 3.8)
- ❌ NEVER use `.withOpacity()` - use `.withValues(alpha: 0.x)` instead
- ❌ NEVER hardcode text colors without using smart color function
- ❌ NEVER use hardcoded color values - use AppColors instead
- ❌ NEVER use `Opacity` widget - use `AnimatedOpacity` for animations
- ❌ Avoid deprecated Flutter 3.8 APIs

---

## Testing Protocol

### Test Structure per Module
```dart
void main() {
  group('PeriodRepository', () {
    late PeriodRepository repository;
    late MockSupabaseClient mockSupabase;

    setUp(() {
      mockSupabase = MockSupabaseClient();
      repository = PeriodRepository(mockSupabase);
    });

    test('fetchPeriod returns Period when query succeeds', () async {
      when(() => mockSupabase.from('periods').select().eq('id', any()).single())
        .thenAnswer((_) async => {'id': '1', 'startDate': '2025-01-01'});

      final period = await repository.fetchPeriod('1');

      expect(period.id, '1');
      expect(period.startDate, DateTime(2025, 1, 1));
    });

    test('fetchPeriod throws exception when query fails', () {
      when(() => mockSupabase.from('periods').select().eq('id', any()).single())
        .thenThrow(Exception('Network error'));

      expect(() => repository.fetchPeriod('1'), throwsException);
    });
  });
}
```

### Test Coverage Requirements
- **Unit tests**: All business logic, utilities, models, repositories
- **Widget tests**: All custom widgets and screens
- **Integration tests**: Critical user flows (period logging, cycle predictions)
- **Minimum coverage**: 80% for business logic

### Test Maintenance Workflow
After every feature change:
1. Run existing tests to identify breaks: `flutter test`
2. Update affected test cases
3. Add new tests for new functionality
4. Verify coverage hasn't decreased
5. Commit tests with feature code (never commit untested features)

---

## File Structure

```
lib/
├── main.dart                    # App entry point, theme configuration
├── config/
│   └── supabase_config.dart    # Supabase initialization
├── constants/
│   └── app_colors.dart         # Centralized theme-aware colors
├── models/
│   ├── cycle.dart              # Cycle data model
│   ├── mood.dart               # Mood logging model
│   ├── period.dart             # Period tracking model
│   ├── symptom.dart            # Symptom logging model
│   └── sexual_activity.dart    # Activity tracking model
├── providers/
│   ├── calendar_provider.dart  # Calendar state management
│   ├── daily_log_provider.dart # Daily log state management
│   └── period_provider.dart    # Period tracking state management
└── screens/
    └── main/
        └── home_screen.dart     # Primary dashboard

test/
├── models/
├── providers/
└── screens/
```

---

## Common Tasks

### Adding a New Section to Home Screen
1. Create `_buildXyzSection()` method in home_screen.dart
2. Wrap in `Container` with AppColors.darkBackground and responsive sizing:
```dart
Widget _buildXyzSection() {
  return Container(
    margin: EdgeInsets.all(_getResponsiveSize(context, 16)),
    padding: EdgeInsets.all(_getResponsiveSize(context, 16)),
    decoration: BoxDecoration(
      color: AppColors.darkBackground,
      borderRadius: BorderRadius.circular(12),
      boxShadow: [
        BoxShadow(
          color: Colors.black26,
          blurRadius: 8,
          offset: Offset(0, 2),
        ),
      ],
    ),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Section Title',
          style: TextStyle(
            fontSize: _getResponsiveFontSize(context, 18),
            fontWeight: FontWeight.bold,
            color: _getTextColorForBackground(AppColors.darkBackground),
          ),
        ),
        // Content
      ],
    ),
  );
}
```
3. Add to build() method Column children
4. Use smart text colors via `_getTextColorForBackground()`
5. Write widget tests for new section

### Adding a New Prediction Display
1. Calculate date based on cycle logic
2. Format date as `DateFormat('MMM d').format(date)`
3. Use FontAwesome icon for visual representation
4. Create display using `_buildSimplePredictionRow()`:
```dart
Widget _buildSimplePredictionRow(IconData icon, String label, String date) {
  return Padding(
    padding: EdgeInsets.symmetric(vertical: _getResponsiveSize(context, 8)),
    child: Row(
      children: [
        FaIcon(
          icon,
          color: AppColors.primary,
          size: _getResponsiveFontSize(context, 20),
        ),
        SizedBox(width: _getResponsiveSize(context, 12)),
        Expanded(
          child: Text(
            label,
            style: TextStyle(
              fontSize: _getResponsiveFontSize(context, 14),
              color: _getTextColorForBackground(AppColors.darkBackground),
            ),
          ),
        ),
        Text(
          date,
          style: TextStyle(
            fontSize: _getResponsiveFontSize(context, 14),
            fontWeight: FontWeight.bold,
            color: _getTextColorForBackground(AppColors.darkBackground),
          ),
        ),
      ],
    ),
  );
}
```
5. Use appropriate phase color from AppColors
6. Write unit tests for prediction logic

### Updating Colors in AppColors
1. Add/modify in `lib/constants/app_colors.dart`
2. Create context-aware methods if light/dark theme variants needed:
```dart
static Color getNewColor(BuildContext context) {
  return Theme.of(context).brightness == Brightness.dark
      ? Color(0xFF...)  // dark variant
      : Color(0xFF...); // light variant
}
```
3. Replace all hardcoded usages with new AppColors method
4. Verify with `_getTextColorForBackground()` for readability
5. Test in both light and dark themes

### Adding a New Provider
1. Create file in `lib/providers/`
2. Define state class with `copyWith()` method
3. Create StateNotifier subclass
4. Define provider with appropriate type
5. Write unit tests for all state transitions
6. Document provider usage in code comments

---

## Performance Guidelines

### Flutter 3.8 Optimizations
- Use `const` constructors wherever possible
- Avoid rebuilding entire widget trees (use `Builder`, `Consumer`)
- Cache network images with `cached_network_image`
- Implement pagination for lists
- Profile with DevTools before optimizing

### Common Pitfalls to Avoid
- Don't use `setState()` in build methods
- Avoid deeply nested widgets (extract to methods/widgets)
- Don't perform heavy operations in build()
- Minimize use of `Opacity` widget (use `AnimatedOpacity`)
- Avoid unnecessary Supabase queries (cache when possible)

---

## Dependencies Management

### Current Dependencies
```yaml
dependencies:
  flutter:
    sdk: flutter
  
  # State Management
  flutter_riverpod: ^2.3.6
  
  # Backend
  supabase_flutter: ^1.10.0
  
  # UI/Icons
  font_awesome_flutter: ^10.4.0
  google_fonts: ^5.0.0
  
  # Utilities
  intl: ^0.18.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.1
  mocktail: ^0.3.0
```

---

## Testing Checklist

Before committing changes:
- [ ] No compilation errors: `flutter analyze`
- [ ] All tests pass: `flutter test`
- [ ] Coverage maintained/increased: `flutter test --coverage`
- [ ] Dark theme compatible (all text readable)
- [ ] Light theme compatible (all colors appropriate)
- [ ] Responsive sizing works on different screen sizes
- [ ] Supabase integration functional
- [ ] FontAwesome icons display correctly
- [ ] Prediction dates calculate correctly
- [ ] No deprecated API usage
- [ ] Smart text colors applied to all text on backgrounds
- [ ] No hardcoded colors (all use AppColors)
- [ ] Provider state updates correctly
- [ ] Widget tests written for UI changes
- [ ] Unit tests written for business logic changes

---

## Documentation References

- **Design**: See [DESIGN_GUIDELINES.md](../../DESIGN_GUIDELINES.md)
- **Features**: See [FEATURES_ADDED.md](../../FEATURES_ADDED.md)
- **Database**: See [SUPABASE_SETUP.md](../../SUPABASE_SETUP.md)
- **Spec**: See [SPEC.md](../../SPEC.md)
- **Prompting**: https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/overview

---

## Recent Architectural Decisions

### Smart Text Color Implementation
**Decision**: All text on colored backgrounds automatically adapts contrast
- **Benefit**: Improves accessibility, reduces readability issues
- **Implementation**: `_getTextColorForBackground()` with `Color.computeLuminance()`
- **Applied To**: FilterChip labels, icons, prediction dates, section titles

### Week Strip Redesign
**Decision**: Week strip shows actual prediction phases, not just cycle math
- **Benefit**: Visual alignment with logged data and predictions
- **Implementation**: Check if each date falls into prediction ranges
- **Colors**: Phase colors change based on predicted ranges

### Minimal Dark Design
**Decision**: Simplified card design with dark backgrounds instead of gradients
- **Benefit**: Cleaner, more modern look, better dark mode support
- **Removed**: Complex gradient progress bars, multiple colored rows
- **Kept**: Simple LinearProgressIndicator, clean prediction display

### Testing-First Development
**Decision**: Tests must be written immediately after each module
- **Benefit**: Catches bugs early, ensures maintainable code
- **Implementation**: No feature PRs accepted without tests
- **Coverage Goal**: 80% minimum for business logic

---

## Summary

This agent follows these rules to deliver:
- Standout design tailored to young adult demographic (20-35)
- Clean, readable code without AI fluff
- Comprehensive testing after each module with updates after feature changes
- Compatibility with Flutter 3.8
- Easy-to-maintain codebase
- Accessible, theme-aware UI that works in light and dark modes
- Consistent cycle predictions with medical accuracy
- Performance-optimized Flutter implementation

Every decision prioritizes user experience, code quality, and maintainability.